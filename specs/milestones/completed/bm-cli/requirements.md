# Requirements — `bm` CLI

> Q&A record for Milestone 3. Questions and answers appended during requirements clarification.

---

## Q1: What's broken or painful about the Justfile approach today?

You have `just init`, `just add-member` (now `hire`), `just create-workspace`, `just launch` (now `start`), `just bootstrap-labels` — they work. What's driving the move to a dedicated CLI? Is it specific friction points (e.g., can't wake a sleeping member, no visibility into running members, managing knowledge is manual), or is it more that the Justfile approach hits a ceiling as the system grows?

**A1:** Three pain points:

1. **Marketing/packaging** — "just xyz" feels like shipping a bunch of makefiles and prompt files, not a product. This blocked publishing the docs site — it didn't feel shippable.
2. **Fragility** — Justfiles are text files that users can edit and break. They're generated by Claude Code, so debugging broken Justfiles means understanding generated code.
3. **Upgrade/shipping** — No versioning or upgrade path. When the profile or process changes, how do you propagate? Copy Justfiles + PROCESS.md + ralph.yml + CLAUDE.md? What if the user customized them? With a binary CLI (like a Helm chart), you version the tool, handle upgrades, and ship docs with each release. The CLI forces proper abstraction boundaries between "tool logic" and "user config."

---

## Q2: What's the scope boundary for this milestone?

Devil's advocate analysis surfaced a risk: the full vision (daemon, wake-up, knowledge management, observability) is large. The **upgrade problem** is the strongest driver — it's genuinely unsolvable with Justfiles. But `bm start` and `bm init` are re-implementations of working recipes.

So: is this milestone about building the full `bm` CLI vision in one shot, or is there a narrower "steel thread" that delivers the highest-value capability first?

**A2:** The CLI *is* the product. Without it, botminter is "a bunch of Justfiles and prompts" — you can't attract users by saying "I know how to run agentic teams, here are some text files." But if you say "here's one CLI that does everything for you — e2e UX, no manual text editing, no browsing directories and reading files" — that's a product.

The process, profiles, knowledge scoping — all of that is valuable, but it's *implementation detail* that the user shouldn't need to see. The CLI is the surface that makes it accessible. This isn't about wrapping working recipes in a nicer package — it's about making the *product* exist. Without the CLI, there is no product to publish.

Scope: **full.** The CLI needs to be the complete operator experience.

---

## Q3: What does the user's first 10 minutes look like?

Imagine someone discovers botminter, installs `bm`, and wants to try it. Walk me through what they'd do — not the internal mechanics, but the commands they'd type and what they'd see. What's the "hello world" journey that makes someone say "oh, this is real"?

**A3:** See `UX.md` for the full walkthrough. Key UX patterns:

1. **`bm init`** — Interactive wizard. Asks workspace location, team name, profile choice, GitHub repo (offers to create it), members, projects. Shows summary, confirms, then creates everything.
2. **`bm teams list`** — Multi-team support. One `bm` installation manages multiple teams. One team is the default.
3. **`bm start -t hypershift`** (alias: `bm up`) — Brings the whole team to life with one command. `-t` flag for team selection, optional (defaults to default team).
4. **`bm status`** — Dashboard view: profile, members, each member's status (alive/dead), Ralph state.
5. **`bm members list -t hypershift`** — List members of a team.
6. **`bm knowledge`** — No verb → drops into interactive mode for CRUD operations. Subcommand without verb = interactive.

Key design pattern: **noun-verb with interactive fallback.** `bm knowledge add ...` for scripting, `bm knowledge` alone for interactive exploration.

---

## Q4: Where does `bm` end and the team repo begin?

Today the team repo is self-contained — it has the Justfile, the member configs, the process docs, everything. With `bm`, some of that logic moves into the binary. But the team repo still needs to exist (it's the GitHub coordination surface).

So what lives where?

- Does the team repo still contain ralph.yml, PROMPT.md, CLAUDE.md, knowledge/, etc. for each member? Or does `bm` generate those on the fly?
- Does `bm` store its own state about teams in `~/.botminter/`? (The UX sketch implies yes — multi-team, default team, workspace paths.)
- When someone does `bm start`, is `bm` reading the team repo to discover members and their configs, or is it reading its own registry?
- Put differently: if I delete `~/.botminter/` but the team repo still exists on GitHub, can I recover with `bm init --from github.com/bot-squad/team-repo`?

**A4 (partial):** On the knowledge/invariants/agents/skills question — these are ever-growing directories that live in the team repo. `bm knowledge` doesn't do direct file CRUD. It launches a **Claude Code instance** configured as a "knowledge management assistant" — with context about the team, where knowledge is stored, what the format looks like, and a `/bm-knowledge` skill. The Claude instance does the actual work interactively with the user.

Same pattern for other management commands — `bm` is a **launcher for purpose-specific Claude Code sessions**, not a file manager.

*Remaining sub-questions (state boundary, team repo vs. ~/.botminter/, recovery) still open.*

---

## Q5: How far does the "launch a Claude Code session" pattern extend?

So `bm knowledge` launches a Claude Code instance as a knowledge management assistant. `bm start` launches Ralph instances as team members. Does this pattern apply to everything?

- **`bm init`** — Is this also a Claude Code session (an "init wizard assistant"), or is it direct CLI logic (prompts, file copying, git operations)?
- **`bm status`** — Is this a Claude session that inspects the system, or direct CLI output (read state, format, print)?
- **`bm teams list`**, **`bm members list`** — Claude sessions or direct CLI?

I'm trying to find the line between "things `bm` does directly" (fast, deterministic, no LLM cost) and "things `bm` delegates to Claude" (interactive, creative, needs judgment). Where's that boundary for you?

**A5:** The boundary is **deterministic vs. freeform content:**

**`bm` does directly (deterministic, no LLM):**
- Creating directory structures
- Printing status (is this member up?)
- Listing entries (teams, members, knowledge files)
- Init wizard (prompts, file copying, git operations)
- Launch, stop, restart members
- All structural/mechanical operations

**`bm` delegates to Claude (freeform content, needs judgment):**
- Knowledge and invariants — they have frontmatter properties but the content and shape are freeform. Claude helps the user *generate effective* knowledge and invariants, not just create files.
- Future: PROMPT.md and ralph.yml authoring — Claude helps the user design processes and configure member behavior. But this is a later feature; M3 uses the existing ones as-is.

**The pattern:** `bm` installs skills into Claude Code sessions. When the user needs help generating *content* (not structure), `bm` launches Claude with the right skills and context. This is a general extensibility pattern — more Claude-assisted features can be added over time.

---

## Q6: What's the source of truth — `~/.botminter/` or the team repo?

The UX sketch shows `bm teams list` returning multiple teams, and `bm start -t hypershift` selecting one. This means `bm` maintains a **local registry** of teams somewhere (presumably `~/.botminter/`).

But the team repo on GitHub also defines the team — its members, their configs, the process. So there are potentially two sources of truth.

Which owns what? For example:
- If I `git push` a new member directory to the team repo, does `bm members list` pick it up automatically? Or do I need `bm hire` to register it?
- If I `bm hire dev` on my machine, does it only exist locally until I push? Or does `bm` push to the team repo immediately?
- Is `~/.botminter/` just a cache/index of team repos the user has cloned, or does it hold state that doesn't exist anywhere else?

**A6:** Git is the source of truth. `~/.botminter/` is a minimal index — filesystem locations, credentials, default team pointer. Nothing unique lives there. If you delete it, you can reconstruct it from the team repos that exist on disk or GitHub.

This means:
- `bm members list` reads the team repo (the `team/` directory), not a local registry
- `bm hire` modifies the team repo (adds files, commits), and `bm` discovers it from git
- `~/.botminter/` is a convenience layer — "I know about these team repos at these paths" — not a state store

---

## Q7: What happens when you close your laptop?

`bm start` brings the team to life. But Ralph instances are Claude Code processes — they consume resources, they can crash, they eventually idle. Today with the Justfile approach, if you walk away and come back, the Ralph process might still be running (or not).

With `bm`:
- When I close my laptop (or the terminal), do members die? Should they survive (background daemon keeping them alive)? Or is it fine if they die and `bm start` restarts them?
- Is `bm start` idempotent — if a member is already running, does it skip it? Restart it? Warn?
- Is there a `bm stop` to shut members down gracefully?
- When a member is idle (no work on the board), should it keep polling, or should it sleep and get woken up by `bm wake`?

**A7:** Members run as background processes on the operator's machine. If a member crashes while the machine is up, ideally it should auto-restart — but **not P0**. For M3, manual `bm start` to bring them back is fine. Laptop close/sleep → members die; when laptop wakes, they should come back — also not P0.

*Still open: idempotency of `bm start`, `bm stop`, idle behavior (poll vs. wake).*

---

## Q8: Who is the M3 user?

You mentioned wanting to publish the docs site and attract people. For this milestone specifically — is the target user:

1. **You** — `bm` needs to work for your own teams (hypershift, etc.) first, and being publishable is a bonus
2. **Early adopters** — developers who'd `go install` / `brew install` and try it on their own repo, meaning install story, docs, and error messages matter from day one
3. **Both** — but if forced to choose, which one wins when there's a tradeoff?

This affects things like: how polished does the install experience need to be? How much error handling? Do we need `bm help` with good docs, or is the README enough?

**A8:** The M3 user is the author and real team members. Not open-source early adopters yet. What wins in tradeoffs is what works for the real team — meaning: the tool needs to be solid enough that teammates can use it without deep knowledge of botminter internals, but doesn't need polished install stories, brew taps, or extensive error messaging for unknown environments.

---

## Q9: Role vs. member — the profile is a template, not a roster

A team is instantiated with one profile. The profile defines the **roles** available (architect, dev, QE, etc.), along with team-level process, skills, and knowledge. But having a role in the profile doesn't mean it's filled — you **hire** a member into a role.

- **Role** — defined by the profile. A template: what hats this role wears, what skills it has, how it participates in the process.
- **Member** — an instance of a role that's been hired into the team. Has a workspace, a Ralph instance, runtime state.

So `bm start` starts the **hired members**, not all roles defined by the profile. `bm hire <role>` fills a position from the profile's available roles.

`bm members list` shows who's been hired. `bm roles list` shows available roles from the profile (the team's "job descriptions").

---

## Q10: What does `bm` need to know to start a member?

Today `just launch` takes `--telegram-bot-token` and `--gh-token`. With `bm start` bringing up the whole team, where do these credentials come from? Are they:

- Stored in `~/.botminter/` as part of the team index (set once during `bm init`)?
- Environment variables the operator exports before running `bm start`?
- Prompted interactively on first run and cached?

**A10:** Stored in `~/.botminter/`, collected during `bm init` or `bm hire`. Credentials are part of the local index — not in git (secrets don't belong in the team repo). `bm start` reads them from there, no flags needed.

---

## Q11: What happens to the Justfile and the skeleton model?

Today botminter is a *generator* — `just init` stamps out a team repo from a skeleton + profile. The team repo has its own Justfile with operational recipes.

With `bm`, the operational recipes move into the binary. But what about the generator model itself?

- Does `bm init` still copy a skeleton into a new git repo? Or does it create a team repo with a different structure (maybe simpler, since `bm` handles the operations)?
- Does the team repo still need a Justfile at all, or is `bm` the only interface?
- Does the skeleton/profile concept survive inside `bm` (baked into the binary), or does `bm` read profiles from a profiles directory at runtime?

**A11:**
- Yes, skeletons still exist. For the first sprint, keep the exact same setup — same directory structure, same profiles, same content.
- Justfiles are **removed**. `bm` replaces them entirely. If users want their own task runner (Justfile, Taskfile, Make), that's their choice — botminter doesn't ship one.
- The `skeletons/team-repo/` skeleton should be **collapsed into the profile**. The current two-layer model (generic skeleton + profile overlay) becomes a single layer — the profile contains everything. *(More on this later.)*
- Where profiles live, how `bm` discovers them — to be clarified.

---

## Q12: What does the team repo look like after `bm init`?

Today the team repo has: `team/`, `projects/`, `knowledge/`, `invariants/`, `.github-sim/` (removed), `agent/skills/`, a Justfile, PROCESS.md, CLAUDE.md, etc. Some of this was the generic skeleton, some came from the profile overlay.

If we collapse skeleton into profile and remove the Justfile, the team repo becomes simpler. But what's left? Roughly:

- `team/<member>/` — hired members with their ralph.yml, PROMPT.md, etc.
- `projects/` — project-specific knowledge
- `knowledge/`, `invariants/` — team-level knowledge
- `agent/skills/` — shared skills (like the `gh` skill)
- PROCESS.md, CLAUDE.md — team process and context

Is that about right, or do you see the team repo structure changing more fundamentally with `bm`?

**A12:** Yes, that's right. The team repo structure stays essentially the same minus the Justfile. `bm` is the operator interface; the team repo is the source of truth for team definition, process, and knowledge.

---

## Q13: Collapsing skeleton into profile — what moves where?

You said to collapse `skeletons/team-repo/` into the profile. Today the split is:

- **`skeletons/team-repo/`** (process-agnostic): directory structure (`team/`, `projects/`, `knowledge/`, `invariants/`), `agent/skills/gh/`, the (now removed) Justfile
- **`skeletons/profiles/rh-scrum/`** (process-specific): PROCESS.md, CLAUDE.md, `members/`, `knowledge/`, `invariants/`, `agent/skills/`

If we collapse, the profile becomes self-contained — it defines everything needed to stamp out a team repo. The only thing currently "shared" across profiles at the skeleton level is `agent/skills/gh/SKILL.md`. Does that just get duplicated into each profile, or does `bm` own it (baked into the binary or a shared assets directory)?

**A13:** See UX.md "profile schema" section. The new structure:

- `skeletons/` goes away. Replaced by `profiles/` at repo root.
- Each profile is fully self-contained: `agent/`, `invariants/`, `knowledge/`, `members/`, `CLAUDE.md`, `PROCESS.md`.
- Each profile has a **`botminter.yml`** — like Helm's `Chart.yaml`. Contains description, display name, schema version, profile version.
- Each profile has a **`.schema/`** directory with versioned schema files (e.g., `v1.yml`). The schema defines the structure: where knowledge lives, where invariants live, where projects live — for both team-level and member-level scopes.
- Schema version starts at v1. This is the foundation for the upgrade story — `bm` knows the schema version and can migrate between versions.

---

## Q14: Where do profiles live at runtime?

The profile is the template that `bm init` stamps from. But where does `bm` find profiles?

- **Baked into the binary** — profiles ship as embedded assets in the `bm` binary. New profile = new `bm` release.
- **In the botminter repo** — `bm` reads from a local clone of the botminter repo (like Helm reading a chart repo).
- **In a registry** — profiles are published somewhere (GitHub releases, OCI registry, simple git repo) and `bm` fetches them.
- **On disk** — a directory like `~/.botminter/profiles/` where the user installs profiles.

Which model fits? This also affects how third parties could create custom profiles later.

**A14:** Baked into the binary for now. Profiles ship as embedded assets. New profile or profile update = new `bm` release. External profile sources (registry, local directory) can come later.

---

## Q15: What language for `bm`?

The binary needs to:
- Embed profile assets (directories of markdown, YAML, skills)
- Launch and manage Claude Code processes
- Serve an interactive CLI (wizard flows, status display)
- Talk to git and `gh`
- Eventually manage background processes (daemon / process supervisor)

Multiclaude uses Go. Go has good embed support, process management, and cross-compilation. But you also have the existing bash tooling and Ralph is in the Rust ecosystem. Any preference or constraints?

**A15:** Rust. Aligns with the Ralph ecosystem, single toolchain for both projects.

---

## Q16: What does `bm status` show the operator?

The UX sketch shows member name + "Status: Alive" + "some ralph status." What does the operator actually need to see to know things are working?

- Just alive/dead per member?
- What each member is currently working on (issue number, hat)?
- How long they've been idle?
- Recent activity log?

What would make you glance at `bm status` and feel confident the team is doing its job?

**A16:** Per member: alive/dead, start time. Plus agent runtime details — currently Ralph-specific:

- `ralph hats` — available hats for the member
- `ralph loops list` — orchestration loop history
- `ralph events` — recent events
- `ralph bot status` — bot connectivity

Future ideas: `ralph bot daemon` status, keystore status.

`bm status` aggregates these across all hired members into a single dashboard view. The specifics of what "agent runtime" means may change if the runtime changes, but for now it's Ralph.

---

## Q17: What does `bm` do about projects?

The UX sketch shows `bm init` asking "Want to add projects?" Today, projects provide scoped knowledge and invariants for a specific codebase the team works on.

What does project management look like through `bm`? Is it:
- Just telling `bm` "this team works on repo X" and it sets up the `projects/<name>/` directory structure?
- Does `bm` clone the project repo into the member's workspace?
- Can a team work on multiple projects simultaneously?

**A17:** Answered as part of Q18 (workspace model).

---

## Q18: Workspace model — the botminter workzone

**Understanding based on user input:**

There's a **botminter workzone** — a top-level directory that `bm` owns and can always find (path stored in `~/.botminter/`). All team directories live inside it:

```
~/.botminter/workspaces/                       # the workzone (configurable)
  my-team/                                      # team name
    team/                                       # team repo (control plane)
    architect/                                  # member (hired role)
      hypershift/                               # project workspace
      cluster-api/                              # another project workspace
    human-assistant/                            # another member
      hypershift/
      cluster-api/
```

Member → project hierarchy. The member is the operational unit (you hire, start, and check status of members). Each project directory under a member is a workspace: a checkout of the team's fork on that member's branch, overlaid with layered knowledge (team → project → member).

A team can work on multiple projects. A member always has a project subdirectory, even with a single project — no special cases.

**Fork model:** upstream project → human's fork → team's fork → member branches. Each member workspace is a checkout of the team's fork on a branch for that member, overlaid with knowledge (team → project → member scoping).

**`bm` does the same thing today's Justfiles do:**
- `bm init` → creates the team directory inside the workzone, inits the team repo (like `just init`)
- `bm hire <role>` → copies role skeleton into `team/<role>/` in the team repo (like `just add-member`)
- Creating a member workspace → clones the team's fork, overlays knowledge/config, symlinks PROMPT.md/CLAUDE.md, copies ralph.yml, assembles `.claude/agents/` (like `just create-workspace`)
- `bm start` → syncs workspaces, launches Ralph in each (like `just launch`)

**The key new thing:** the workzone is a known, discoverable location. `bm` can find teams and workspaces from anywhere — no scanning sibling directories for `.member` markers.

**Discrepancy check against current Justfiles:** No functional discrepancy. The mechanics are the same — clone, overlay, symlink, launch. The differences are:
1. **Discoverability** — known workzone path vs. scanning siblings
2. **UX** — interactive CLI vs. recipe flags
3. **Credentials** — stored in `~/.botminter/` vs. passed as flags every time
4. **Multi-team** — first-class concept vs. one team repo per directory

---

## Q19: What does `bm` do that the Justfiles can't?

We've established that `bm` replaces the Justfiles mechanically. But you also mentioned capabilities the Justfiles don't have today:

1. **`bm wake <member>`** — signal an idle member to check for work. Today there's no wake mechanism. How important is this for M3? Is it "nice to have" or essential?
2. **`bm knowledge`** (Claude-assisted) — launching a Claude session for knowledge management. Is this in M3 scope or a later feature?
3. **`bm upgrade`** — the killer feature from Q1. Is this in M3 scope, or does M3 just establish the versioned profile structure (`botminter.yml` + `.schema/`) so upgrade can come in a follow-up?
4. **`bm validate`** — checking workspace health. In scope?

Which of these are M3 must-haves vs. later?

**A19:** M3 scope is replacing the Justfiles — `bm init`, `bm hire`, `bm start`, `bm status`, `bm members list`, `bm teams list`, `bm roles list`. Plus the new workzone structure, stored credentials, and the versioned profile model (`botminter.yml` + `.schema/`).

Everything else — `bm wake`, `bm knowledge` (Claude-assisted), `bm upgrade`, `bm validate` — is later. M3 establishes the foundation; those features build on it.

---

## Q20: Does `bm` live in this repo or a new one?

`bm` is a Rust binary. Ralph is also a Rust binary in a separate repo (`ralph-orchestrator`). Does `bm`:

- Live in this repo (`botminter`) — alongside the profiles it embeds?
- Get its own repo (`bm` or `botminter-cli`)?
- Live in the Ralph repo as a workspace crate?

**A20:** `bm` lives in this repo (`botminter`). Ralph is an upstream project — `bm` depends on it at runtime (launches `ralph run`) but doesn't share a codebase. The profiles that `bm` embeds are also in this repo.

---

## Q21: `bm start` / `bm stop` lifecycle — how does it map to Ralph?

Gap identified during requirements review: `bm start` starts all members, but the underlying mechanics (process tracking, stop mechanism) weren't specified.

**A21:** Direct mapping to Ralph CLI commands:
- `bm start` → runs `ralph run` for each hired member
- `bm stop` → runs `ralph loops stop` for each running member

No custom process supervision for M3. `bm` delegates lifecycle management to Ralph's existing CLI.

---

## Q22: How does the team repo know which profile created it?

Gap identified during requirements review: after `bm init`, the team repo needs to remember its profile and schema version so `bm hire`, `bm status`, etc. know what roles are available and how to interpret the directory layout.

**A22:** `botminter.yml` is copied into the team repo root during `bm init`. It records the profile name, schema version, and profile version. This is how `bm` knows what it's working with when operating on an existing team repo.

---

## Q23: Where are project fork URLs stored, and who creates workspaces?

Gap identified during design review (G1, G2): the design bundled workspace creation into `bm start`, but the UX doc and current Justfile model separate provisioning from operations. Also, `bm start` needs to know project fork URLs to clone workspaces, but nothing stored them.

Two sub-questions:
1. Where does `bm` store project fork URLs so it knows what to clone?
2. What command creates/syncs member workspaces?

**A23:**

**Fork URLs live in `botminter.yml` in the team repo.** The file starts as profile metadata (copied from the embedded profile during `bm init`) and gets augmented with team-specific configuration:

```yaml
# team repo root: botminter.yml
name: rh-scrum
display_name: "Red Hat Scrum Team"
version: "1.0.0"
schema_version: v1

# team-specific config (added by bm init / bm projects add)
projects:
  - name: hypershift
    fork_url: git@github.com:bot-squad/hypershift.git
  - name: cluster-api
    fork_url: git@github.com:bot-squad/cluster-api.git
```

**Workspace creation is done by `bm teams sync`, not `bm start`.** Command responsibilities:

- `bm init` — creates team, collects config (profile, projects, members), writes `botminter.yml`. Does NOT create member workspaces.
- `bm hire <role>` — adds member skeleton to team repo. Does NOT create workspaces.
- `bm projects add <url>` — adds project entry to `botminter.yml`. Does NOT create workspaces.
- `bm teams sync` — reconciles workspaces with team repo state. Creates missing member/project workspaces, syncs existing ones, propagates changes. Reads `botminter.yml` for projects, reads `team/` for hired members.
- `bm start` — launches Ralph in existing workspaces. Does NOT create or sync workspaces.

---

## Q24: Where are GitHub labels defined in the profile?

Gap identified during design review (G4): `bm init` bootstraps GitHub labels, but labels are profile-specific. Currently hardcoded in the Justfile. Where should they live in the profile?

**A24:** Labels live in `botminter.yml` under a `labels:` section. Since `botminter.yml` is the single manifest for profile identity and configuration, labels belong there alongside metadata and schema version. Different profiles define different label schemes. `bm init` reads the labels from the team repo's `botminter.yml` (copied from the profile) and calls `gh label create` for each.

---

## Q25: Does `bm hire` / `bm projects add` auto-push to GitHub?

Concern raised during design review (C2): the design had `bm hire` auto-pushing to GitHub. Should `bm` commands that modify the team repo auto-push?

**A25:** No. Commands that modify the team repo (`bm hire`, `bm projects add`) commit locally but never auto-push. Pushing is explicit via `bm teams sync --push`. This lets the operator batch changes:

```bash
bm hire architect --name bob     # local commit
bm hire dev --name charlie       # local commit
bm projects add <url>            # local commit
bm teams sync --push             # push to GitHub + reconcile all workspaces
```

---

## Q26: How does `bm stop` work — graceful vs. force?

Concern raised during design review (C3): the design had a sequential fallback (try `ralph loops stop`, then SIGTERM after timeout). How should stop actually work?

**A26:** Two distinct modes controlled by a flag:

- `bm stop` (default) — runs `ralph loops stop` for each running member. Graceful shutdown via Ralph's own mechanism.
- `bm stop --force` / `-f` — uses tracked PIDs from `state.json` to force-kill processes. The operator's escape hatch when Ralph isn't responding.

PID tracking in `state.json` exists specifically for the force-stop case. No automatic timeout fallback — the operator decides.

---

## Q27: Can multiple members fill the same role?

Concern raised during design review (C4): the design had member name = role name (1:1 mapping). What if a team needs two developers?

**A27:** Members have unique identities separate from roles. `bm hire` takes an optional `--name`:

- `bm hire architect --name bob` → creates `team/architect-bob/`
- `bm hire dev --name charlie` → creates `team/dev-charlie/`
- `bm hire dev` (no name) → creates `team/dev-03/` (auto-generated unique 2-digit suffix)

The directory naming convention is `{role}-{name}` for filesystem discoverability (you can glob `team/dev-*` to find all devs).

The member's name and role are recorded in the member's own `botminter.yml` inside the member directory (where comment format, emoji, and other member-specific config also live).

---

## Q28: Profile exploration commands

The operator needs to know what profiles are available and what's in them before running `bm init`.

**A28:** Two commands:

- `bm profiles list` — lists all embedded profiles with name, version, and description. Reads from embedded `botminter.yml` metadata.
- `bm profiles describe <profile>` — shows full profile details: metadata, available roles (from `members/` directory), labels (from `labels:` section). The drill-down from `list`.

---

## Final M3 Command Tree (post design review)

```
bm
├── init                           # Interactive wizard — create team
├── hire <role> [--name <name>] [-t team]
├── start [-t team]                # Start all members (alias: bm up)
├── stop [-t team] [--force/-f]    # Stop all members
├── status [-t team]               # Status dashboard
├── teams
│   ├── list                       # List all teams
│   └── sync [--push]              # Reconcile workspaces + optional push
├── members
│   └── list [-t team]             # List hired members
├── roles
│   └── list [-t team]             # List available roles from profile
├── profiles
│   ├── list                       # List embedded profiles
│   └── describe <profile>         # Show profile details (roles, labels, metadata)
└── projects
    └── add <url> [-t team]        # Add project to team
```

---
