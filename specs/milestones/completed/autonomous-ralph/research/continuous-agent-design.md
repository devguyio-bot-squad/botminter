# Continuous GitHub Issue Agent: Design Report

Ralph's orchestration model is built around convergence: a fixed objective, iterative progress, and termination when the goal is met. Running Ralph as a continuous agent that pulls tasks from GitHub issues requires working with — or around — this design. This report examines the relevant internals, identifies the friction points, and presents two proposals.

---

## Part 1: How Ralph Uses the Prompt Today

> **Terminology note:** This report uses **"turn"** to mean one LLM invocation — one prompt sent, one response received. Each hat activation is a separate turn. Ralph's config uses `max_iterations` for the same concept; this report avoids "iteration" in prose to prevent confusion with "one full pass through a multi-hat workflow," which may span many turns.

### The Objective Is Immutable and Convergent

The user provides a prompt file (default: `PROMPT.md`) containing the objective — plain text describing what the agent should accomplish. This might be as simple as:

```markdown
Add retry logic to webhook delivery.
Retry up to 3 times with exponential backoff.
```

That's all the user writes. Ralph loads this file once at startup and stores it as an immutable string. The user's text never changes during the loop.

**Ralph then wraps the user's text in generated scaffolding.** Every turn, the objective appears in two places in the agent's prompt — neither of which the user controls:

**At the top**, Ralph generates a `## OBJECTIVE` section that frames the user's text:

```
## OBJECTIVE                                          ← generated by Ralph

**This is your primary goal. All work must advance    ← generated by Ralph
this objective.**

> Add retry logic to webhook delivery.                ← user's text from PROMPT.md
> Retry up to 3 times with exponential backoff.       ← user's text from PROMPT.md

You MUST keep this objective in mind throughout       ← generated by Ralph
the iteration.
```

**At the bottom**, Ralph generates a `## DONE` section that bookends the objective:

```
## DONE                                               ← generated by Ralph

You MUST emit a completion event `LOOP_COMPLETE`      ← generated by Ralph
when the objective is complete and all tasks are done.

**Remember your objective:**                          ← generated by Ralph
> Add retry logic to webhook delivery.                ← user's text, quoted again
> Retry up to 3 times with exponential backoff.

You MUST NOT declare completion until this objective  ← generated by Ralph
is fully satisfied.
```

The user writes the objective; Ralph generates the framing, the completion instructions, and the termination mechanics. This distinction matters because it means the `## DONE` section — the thing that drives termination — is entirely Ralph's construct. The user has no direct control over its wording, only indirect influence through what they put in the prompt file.

### Termination Is Convergence-Based

The loop terminates when any of these conditions are met:

| Condition | Default | Exit Code |
|-----------|---------|-----------|
| Agent emits `LOOP_COMPLETE` | — | 0 |
| Max iterations reached | 100 | 2 |
| Max runtime exceeded | 4 hours | 2 |
| Max cost exceeded | None | 2 |
| Consecutive failures | 3 | 1 |
| Loop thrashing | 3 redispatches | 1 |
| Manual stop (signal file) | — | 1 |
| Restart requested | — | 3 |
| SIGINT/SIGTERM | — | 130 |

The happy path is always `LOOP_COMPLETE` — the agent decides it has satisfied the objective, emits the completion event, and the loop exits cleanly. Every other termination reason is either a safety limit or an external intervention.

### Persistent Mode

Ralph has a built-in mechanism for suppressing termination: `persistent: true` in the event loop config.

When enabled, the event loop intercepts `LOOP_COMPLETE` events and instead of terminating:

1. Logs the suppression to diagnostics
2. Injects a `task.resume` event onto the bus with payload: *"Persistent mode: loop staying alive after completion signal. Check for new tasks or await human guidance."*
3. Returns `None` (no termination)

Hard limits (`max_iterations`, `max_runtime`, `max_cost`) still terminate even in persistent mode. Only the completion promise is suppressed.

The `task.resume` event is not special — it's just a topic string. What happens next depends entirely on what hats are configured and whether any of them subscribe to `task.resume`. If no hat picks it up, it falls through to HatlessRalph in coordinator mode.

### The Scratchpad Provides Continuity

Each turn starts with a completely fresh LLM context — no conversational memory carries over. Continuity comes from the **scratchpad** (or **tasks**, when memories mode is enabled), files the agent writes to disk that are prepended at the very top of the next turn's prompt.

The scratchpad is budgeted at approximately 16,000 characters with tail-preservation: when it exceeds the budget, older content is trimmed from the top, keeping the most recent notes. This means the agent's understanding of "where I am and what I'm doing" is always grounded in its most recent work.

In a single-issue run, the scratchpad accumulates context about that one issue. In a continuous run, notes from issue N are still present when working on issue N+1. **Persistent mode does not clear the scratchpad** — the suppression handler only injects `task.resume` and returns. No cleanup of any kind is performed.

### The `## DONE` Section Is Hat-Gated

The DONE section — which instructs the agent to emit `LOOP_COMPLETE` — is **only injected when no hat is active**:

```rust
if active_hats.is_empty() {
    prompt.push_str(&self.done_section(self.objective.as_deref()));
}
```

When a hat is active (determined by matching pending events against hat subscriptions), the hat's instructions replace the generic workflow, and the DONE section is suppressed. The reasoning: only the coordinator (Ralph without a hat) decides when the loop is done; individual hats should publish events and stop.

### Hats Are Runtime Constructs

Hats are entirely user-defined via YAML configuration. Ralph ships with no default hats — the hat registry builds exclusively from the `hats:` section of the config file. An empty `hats:` section means no hats; HatlessRalph is the fallback.

The codebase contains convenience constructors like `Hat::default_planner()` and `Hat::default_builder()` in `ralph-proto`, but these are never auto-registered. They exist for tests and presets. What hats you run, what topics they subscribe to, what they publish, and what their instructions say — all of that is your design.

This means the relationship between `persistent: true` and the hat topology is a **contract the user must satisfy**: persistent mode will inject `task.resume`, and it's up to your hat configuration to handle it.

### The Restart Mechanism

When a restart is requested (via Telegram `/restart` or signal file), Ralph terminates with exit code 3 and **exec-replaces** the current process with the same CLI arguments. The new process starts fresh — new EventLoop, new state, new event files — but memories and the prompt file persist on disk.

---

## Part 2: The Design Tensions

Shifting from "implement feature X" to "continuously process GitHub issues" creates three friction points:

### Tension 1: The Objective Has No End State

Ralph's objective framing assumes convergence. "All work must advance this objective" and "You MUST NOT declare completion until this objective is fully satisfied" work well when the objective is "add user authentication." They become paradoxical when the objective is "continuously process issues" — that objective is never fully satisfied.

**Persistent mode resolves this.** When the objective is a role ("process GitHub issues"), completing one issue is a natural `LOOP_COMPLETE` moment — the agent has done a unit of work toward the objective. Persistent mode catches this, injects `task.resume`, and the cycle continues. The agent uses `LOOP_COMPLETE` naturally (per-issue), and the event loop reinterprets it as "ready for next task" rather than "all done."

### Tension 2: The Scratchpad Bleeds Across Issues

In a single-issue run, the scratchpad contains notes like "implemented the auth middleware, need to add tests." In a continuous run, when the agent moves from issue #41 to issue #42, the scratchpad still contains #41's notes. The tail-preservation algorithm will eventually shed them, but there's an awkward transition period where the agent reads stale context about a completed issue mixed with notes about the current one.

**Persistent mode does not address this.** The `LOOP_COMPLETE` suppression handler performs no cleanup — no scratchpad reset, no task archival. This is arguably the biggest gap in persistent mode for multi-task workflows.

With memories+tasks enabled, the impact is partially mitigated: tasks provide structured per-issue tracking (the `<ready-tasks>` section only lists open tasks, so closed tasks aren't displayed individually — though they remain on disk and the header shows their count). The scratchpad's narrative role is reduced, but it still carries notes from previous issues until tail-preservation sheds them.

### Tension 3: There's No Idle Mode

When the agent checks GitHub and finds no issues, what should it do? Ralph has no concept of "wait and check again later." Each turn consumes tokens and incurs cost. An agent cycling through turns checking GitHub while nothing is available burns resources for no value.

---

## Part 3: Proposal A — Outer Loop

### Concept

A lightweight external script runs Ralph repeatedly, once per issue. Each run gets a dynamically generated prompt focused on a single issue. Ralph's convergence model is preserved exactly as designed.

```
┌──────────────────────────────────────────────────────────┐
│  Outer Loop (bash / systemd / cron)                      │
│                                                          │
│  1. Query GitHub for next issue                          │
│  2. Generate focused PROMPT.md from issue content        │
│  3. ralph run -P PROMPT.md                               │
│  4. On exit: update issue, go to step 1                  │
│  5. If no issues: sleep, go to step 1                    │
└──────────────────────────────────────────────────────────┘
```

### The Prompt (What the Outer Script Generates)

Each run gets a freshly generated `PROMPT.md` — just the user's objective text, which Ralph will wrap in its `## OBJECTIVE` and `## DONE` scaffolding:

```markdown
# Implement: Add retry logic to webhook delivery (#42)

Webhook deliveries currently fail silently when the target server is
unavailable. Add exponential backoff retry with configurable attempts.

**From issue labels:** `enhancement`, `backend`, `priority:high`

## Requirements
- Retry up to 3 times with exponential backoff (1s, 2s, 4s)
- Log each retry attempt
- Mark delivery as failed after all retries exhausted
- Add configuration option for max retry count

## When Done
- All tests pass
- Create a PR referencing #42
- Comment on the issue with the PR link
```

This is a standard convergent objective. Ralph will wrap "Add retry logic..." in its generated `## OBJECTIVE` framing, and generate a `## DONE` section that instructs the agent to emit `LOOP_COMPLETE` when the work is finished. Every mechanism in Ralph — scratchpad, tasks, hats, termination — works without modification.

### The Outer Script

```bash
#!/bin/bash
REPO="my-org/my-repo"
LABEL="ralph-ready"

while true; do
    # Find the oldest open issue with the target label
    ISSUE=$(gh issue list --repo "$REPO" --label "$LABEL" \
        --state open --limit 1 --json number,title,body --jq '.[0]')

    if [ -z "$ISSUE" ] || [ "$ISSUE" = "null" ]; then
        echo "[$(date)] No issues labeled '$LABEL' — sleeping 5 minutes"
        sleep 300
        continue
    fi

    NUMBER=$(echo "$ISSUE" | jq -r '.number')
    TITLE=$(echo "$ISSUE" | jq -r '.title')
    BODY=$(echo "$ISSUE" | jq -r '.body')

    echo "[$(date)] Starting work on #$NUMBER: $TITLE"

    # Generate a focused single-issue prompt
    cat > PROMPT.md << PROMPT_EOF
# Implement: $TITLE (#$NUMBER)

$BODY

## When Done
- All tests pass
- Create a PR on \`$REPO\` referencing #$NUMBER
- Comment on the issue with the PR link
PROMPT_EOF

    # Mark the issue as in-progress
    gh issue edit "$NUMBER" --repo "$REPO" --add-label "ralph-working"
    gh issue comment "$NUMBER" --repo "$REPO" \
        --body "Ralph is starting work on this issue."

    # Run Ralph with per-issue cost limit
    ralph run -P PROMPT.md --max-iterations 50
    EXIT=$?

    # Post-run cleanup
    gh issue edit "$NUMBER" --repo "$REPO" --remove-label "ralph-working"

    if [ $EXIT -eq 0 ]; then
        echo "[$(date)] Completed #$NUMBER successfully"
    else
        echo "[$(date)] #$NUMBER exited with code $EXIT"
        gh issue comment "$NUMBER" --repo "$REPO" \
            --body "Ralph stopped working (exit code $EXIT). Manual review needed."
    fi

    sleep 30  # brief pause between issues
done
```

### Hats

Hats are configured per-project as usual — whatever topology suits the codebase. The outer loop doesn't change how hats work within a run. You might define hats for planning, implementation, and review, or use a single-hat configuration. The hat topology is orthogonal to the outer loop mechanism.

### Idle Handling

Handled entirely by the outer script: `sleep 300` when no issues are found. Zero tokens consumed during idle periods.

### Strengths

- **Zero code changes to Ralph.** Works today, with the current codebase.
- **Clean issue boundaries.** Each run starts with fresh context — clean scratchpad, clean tasks, clean events. No bleed between issues.
- **Natural termination semantics.** `LOOP_COMPLETE` means "this issue is done." Clear, unambiguous.
- **Cost isolation.** Set `max_cost_usd` per run to cap spending on any single issue.
- **Error isolation.** A catastrophic failure on issue #41 (thrashing, bad code, stuck loop) doesn't affect issue #42. The next run starts clean.
- **Git cleanliness.** Each issue can get its own branch. No entangled commits across issues.
- **Idle efficiency.** The outer script sleeps; no tokens are consumed.
- **Memories bridge issues.** The `.ralph/agent/memories.md` file persists across runs, so learnings like "this codebase uses factory pattern for services" carry forward naturally.

### Limitations

- **Ralph doesn't know it's continuous.** Each run is isolated. The agent can't say "I already fixed a similar issue yesterday" (unless that knowledge made it into memories).
- **Startup cost per issue.** Each run bootstraps a fresh EventLoop, fresh agent session. There's overhead in reading the codebase from scratch each time — though this is exactly what "Fresh Context Is Reliability" prescribes.
- **The outer script is outside Ralph's control.** Monitoring, error handling, and retry logic live in bash, not in the orchestrator. For production use, you'd want to replace the bash loop with something more robust (systemd unit, a small daemon, or the existing `ralph bot daemon` architecture).

---

## Part 4: Proposal B — Persistent Mode with Role Prompt

### Concept

Ralph runs as a single long-lived loop with `persistent: true`. The prompt describes a continuous role rather than a single task. The agent naturally emits `LOOP_COMPLETE` after finishing each issue, and persistent mode converts that into a `task.resume` event that triggers the next work cycle.

```
┌──────────────────────────────────────────────────────────┐
│  Ralph Loop (persistent: true)                           │
│                                                          │
│  loop.start ──► hat A (find work) ──► hat B (do work)    │
│                      ▲                       │           │
│                      │                       ▼           │
│               task.resume              LOOP_COMPLETE     │
│                      ▲                       │           │
│                      │                       ▼           │
│                      └──── persistent mode catches ──────┘
└──────────────────────────────────────────────────────────┘
```

### How Persistent Mode Drives the Cycle

The key mechanism:

1. The agent completes an issue and emits `LOOP_COMPLETE` — the same natural behavior as any Ralph run
2. The event loop's `check_completion_event()` sees `persistent: true` and suppresses termination
3. A `task.resume` event is injected onto the bus
4. Whichever hat subscribes to `task.resume` activates on the next turn
5. That hat's instructions tell it to check GitHub for the next issue
6. The cycle repeats

The agent doesn't need to know about persistent mode. It works toward the objective, declares completion when a unit of work is done, and the event loop handles the rest. `LOOP_COMPLETE` shifts meaning from "all done" to "ready for next task."

### The Contract: `task.resume` Must Be Handled

Persistent mode injects `task.resume` — a plain topic string with no special status. **At least one hat in your topology must subscribe to `task.resume`** for the cycle to work. If no hat picks it up, the event falls through to HatlessRalph in coordinator mode, which sees `## DONE` and may emit `LOOP_COMPLETE` again — creating a tight idle loop.

The hat that handles `task.resume` is the one responsible for finding the next work item. Its instructions should include the logic for querying GitHub, selecting an issue, and kicking off the work cycle. This hat is also where you handle the idle case — when no issues are available, the hat can emit `LOOP_COMPLETE`, and persistent mode will catch it and try again on the next turn.

### No Cleanup Is Guaranteed

When the agent emits `LOOP_COMPLETE`, Ralph does **not** enforce that all tasks are closed or that the workspace is clean. The `## DONE` section instructs the agent to close tasks before declaring completion, but it's just a prompt — not a gate. Ralph logs a warning if open tasks remain (`"trusting agent decision"`) and proceeds.

In persistent mode, this means orphaned state can carry over between issues:

- **Open tasks**: If the agent left tasks open from issue #41, they appear in `<ready-tasks>` when the coordinating hat starts looking for issue #42. The agent may try to work on them instead of picking a new issue.
- **Events on the bus**: Events the agent emitted in the same turn as `LOOP_COMPLETE` (before it) are still on the bus and will appear in `## PENDING EVENTS` on the next turn alongside `task.resume`.
- **Git state**: Uncommitted changes, unmerged branches, dirty working directory — all persist.

The hat that handles `task.resume` must explicitly clean up leftover state before looking for new work. For example: close remaining open tasks, ensure the working directory is on the main branch, discard uncommitted changes.

### The Prompt (What the User Writes)

The user's `PROMPT.md` describes the **role and rules** — just the objective text, nothing else:

```markdown
# Continuous GitHub Issue Agent

You are an autonomous development agent for `my-org/my-repo`.
Process GitHub issues labeled `ralph-ready`, one at a time.

## Rules
- One issue at a time — finish completely before starting another
- Create a feature branch and PR for each issue
- All tests must pass before declaring an issue complete
- Comment on the issue with the PR link when done
- Use memories to record reusable patterns across issues
- When no issues are available, emit LOOP_COMPLETE
```

The prompt is deliberately thin. The *what* and *why* live here; the *how* lives in hat instructions.

### What the Agent Actually Sees (What Ralph Generates)

Ralph wraps the user's text in its scaffolding. The agent sees the user's prompt file content quoted inside the generated `## OBJECTIVE` section near the top, and again in the generated `## DONE` section at the bottom. The `## DONE` section — which instructs the agent to emit `LOOP_COMPLETE` — is entirely Ralph-generated; the user doesn't write it or control its wording.

This matters for persistent mode: the agent interprets "objective is complete" as "the current issue is done" — because completing an issue is the unit of work that advances the role. The `## DONE` section's instruction to emit `LOOP_COMPLETE` works naturally per-issue, and persistent mode recycles it. No special prompting is needed from the user.

### Example Hat Topology

Hats are fully user-defined. Here is one possible topology — not the only one:

```yaml
event_loop:
  persistent: true
  max_iterations: 10000
  max_runtime_seconds: 86400
  max_cost_usd: 50.0
  prompt_file: PROMPT.md

memories:
  enabled: true

tasks:
  enabled: true

hats:
  coordinator:
    triggers: [loop.start, task.resume, build.done]
    publishes: [build.task]
    instructions: |
      You coordinate the work cycle for this agent.

      **On task.resume or loop.start** (between issues):
        1. Clean up leftover state from the previous issue:
           - Close any remaining open tasks: `ralph tools task list`, then close each
           - Ensure working directory is on the main branch: `git checkout main`
           - Discard any uncommitted changes: `git clean -fd && git checkout .`
        2. Query: gh issue list --label ralph-ready --state open --limit 1
        3. If found: read the issue fully, create tasks, emit build.task
        4. If none: emit LOOP_COMPLETE (persistent mode will retry later)

      **On build.done** (implementation complete):
        1. Review the result against the issue requirements
        2. If more work needed: emit build.task with details
        3. If complete: close tasks, comment on issue with PR link, emit LOOP_COMPLETE

  implementer:
    triggers: [build.task]
    publishes: [build.done]
    instructions: |
      Implement the task described in the event payload.
      Write code and tests. Run the test suite.
      Create a branch, commit, and push.
      Create a PR if one doesn't exist yet.
      Emit build.done when implementation is complete.
```

The names, the number of hats, the event topics, and the instructions are all choices. You could have three hats, or five, or one. The only hard requirement is that `task.resume` is in some hat's triggers.

### The Idle Problem

When the coordinating hat finds no issues and emits `LOOP_COMPLETE`, persistent mode catches it and injects `task.resume`. The coordinating hat activates, checks GitHub again, finds nothing, emits `LOOP_COMPLETE` again. This creates a polling loop:

```
coordinator: no issues → LOOP_COMPLETE
persistent mode: suppress → task.resume
coordinator: no issues → LOOP_COMPLETE
persistent mode: suppress → task.resume
...
```

Each cycle is a full turn consuming tokens. Mitigations:

1. **`cooldown_delay_seconds`** — The event loop config has this field, which inserts a delay between *every* turn (skipped only when human events are pending). When Hat A emits `tests.written` and Hat B (reviewer) subscribes to it, the cooldown fires before the reviewer starts. A 300-second setting would mean 5 minutes between every hat transition — unusable during active work. Only viable if a very short delay (5–10 seconds) is acceptable across all transitions, idle or productive.

2. **Outer restart wrapper** — Have the coordinating hat emit `LOOP_COMPLETE` on idle, and don't use persistent mode at all for the idle case. Wrap Ralph in a restart loop:

```bash
while true; do
    ralph run -P PROMPT.md
    EXIT=$?
    case $EXIT in
        0) sleep 300 ;;  # completed or idle — wait before restart
        3) continue ;;   # restart requested
        *) sleep 60 ;;   # error — brief pause
    esac
done
```

3. **RObot integration** — With Telegram enabled, the idle loop doubles as a waiting state for human guidance. The human can send a message with the next issue or a new directive, and the agent picks it up as `human.guidance` in the next turn. This turns the idle loop into a feature rather than a waste.

### The Configuration

```yaml
event_loop:
  persistent: true
  max_iterations: 10000       # high ceiling — each hat activation is one turn
  max_runtime_seconds: 86400  # 24 hours before forced restart
  max_cost_usd: 50.0          # safety cap
  prompt_file: PROMPT.md
  completion_promise: LOOP_COMPLETE

memories:
  enabled: true

tasks:
  enabled: true

# Optional: Telegram for monitoring and steering
RObot:
  enabled: true
  timeout_seconds: 600
  checkin_interval_seconds: 300
```

### Scratchpad Management

Persistent mode does not clear the scratchpad when suppressing `LOOP_COMPLETE`. Notes from the previous issue persist into the next cycle. Two mitigation strategies:

**Strategy 1: Explicit cleanup in hat instructions.**
Add to the coordinating hat: "After completing an issue, clear the scratchpad and write a fresh entry: 'Completed issue #N. Looking for next issue.'" The agent overwrites the file, and the next cycle starts with clean context.

**Strategy 2: Rely on tasks mode.**
With memories and tasks enabled, the scratchpad's role is diminished. Tasks provide structured progress tracking per issue. The agent creates tasks when starting an issue and closes them when done. The `<ready-tasks>` section at the top of each prompt only *lists* open and ready tasks — closed tasks are not shown individually. However, the header still reads `"## Tasks: 0 ready, 0 open, 5 closed"`, and all tasks (including closed ones from previous issues) remain in the `.ralph/agent/tasks.jsonl` file on disk. They are not cleaned up by persistent mode.

### Strengths

- **Single process during active work.** Ralph runs, hats cycle, issues get processed — no external orchestration needed while work is available.
- **Natural completion semantics.** The agent emits `LOOP_COMPLETE` as it would in any run. Persistent mode reinterprets it. No prompt gymnastics needed.
- **`task.resume` is explicit.** The transition from "done with current work" to "find new work" is a concrete event on the bus, not an implicit consequence of hat topology.
- **Memories accumulate naturally.** The agent builds a growing knowledge base about the codebase across issues within the same run.
- **RObot integration.** With a single long-running loop, the Telegram bot provides continuous monitoring. You can watch issues being processed, send guidance, answer questions, and even inject new work — all from your phone.
- **Aligned with the daemon vision.** This aligns with the existing `ralph bot daemon` architecture — a persistent process that does work when work is available.

### Limitations

- **Scratchpad bleed between issues.** The scratchpad is not cleared on `LOOP_COMPLETE` suppression. Notes from previous issues carry over until tail-preservation sheds them. Mitigation requires explicit cleanup in hat instructions.
- **No cost isolation per issue.** A single `max_cost_usd` covers the entire run. One unexpectedly expensive issue consumes budget that might have been needed for others.
- **Error propagation.** If the agent gets into a bad state on issue N (broken branch, uncommitted changes, confused scratchpad), that state persists into issue N+1. There's no clean reset between issues.
- **Git complexity.** The agent needs to manage branches across issues within a single run — creating, switching, pushing, potentially resolving conflicts. A single-issue run always starts from a clean `main`.
- **The idle problem still needs a solution.** Whether it's `cooldown_delay_seconds`, an outer restart wrapper, or accepting the cost of idle polling, there's no built-in idle mode. Persistent mode converts termination into resumption, but it doesn't know how to wait.

---

## Part 5: Comparison

| Dimension | Proposal A: Outer Loop | Proposal B: Persistent Mode |
|-----------|----------------------|------------------------|
| **Code changes required** | None | None |
| **Issue isolation** | Complete — fresh state per issue | Partial — scratchpad and git state carry over |
| **Termination semantics** | Natural — LOOP_COMPLETE means "issue done" | Natural — LOOP_COMPLETE means "issue done," persistent mode recycles it |
| **Idle handling** | Outer script sleeps — zero cost | Requires mitigation (cooldown, outer wrapper, or accepting cost) |
| **Cost control** | Per-issue budget | Per-run budget (across all issues) |
| **Error recovery** | Automatic — next run starts clean | Manual — bad state persists |
| **Scratchpad** | Clean per issue | Bleeds across issues (mitigable via instructions or tasks mode) |
| **Memories** | Persist across runs | Persist within and across runs |
| **Git management** | Simple — one branch per run | Complex — multiple branches in one run |
| **Telegram monitoring** | Per-issue sessions | Continuous session |
| **Startup overhead** | Per issue | Once |
| **Complexity** | In the bash script | In the hat topology and instructions |
| **Failure mode** | Bash script crashes (simple, recoverable) | Bad state persists (requires hat-level cleanup) |
| **`task.resume` contract** | Not applicable | User must ensure a hat subscribes to `task.resume` |

---

## Part 6: Recommendation

Both proposals work today with no code changes. The choice depends on operational priorities.

**Proposal A (Outer Loop)** is the safer, simpler choice. It preserves every invariant Ralph was designed around — single objective, clean termination, fresh context. The tradeoff is that Ralph doesn't know it's continuous; each run is isolated, and the coordination logic lives outside the orchestrator. For production use, replace the bash loop with a systemd unit or integrate with the `ralph bot daemon` architecture.

**Proposal B (Persistent Mode)** is the more integrated choice. It keeps Ralph running as a single process, uses the built-in `persistent: true` mechanism, and leverages hats for the full work cycle. The tradeoff is scratchpad bleed, error propagation, and the idle problem. This approach works best when combined with RObot (Telegram) for monitoring and steering — the idle loop doubles as a waiting state for human guidance.

As a starting point, **Proposal A is recommended** — it requires less design work, has better error isolation, and the outer script is trivial to write and debug. Once the workflow is validated, migrating to Proposal B is straightforward: change the prompt from task-focused to role-focused, enable `persistent: true`, and ensure the hat topology handles `task.resume`.

The scratchpad not being cleared on `LOOP_COMPLETE` suppression is the most significant gap in persistent mode for multi-task workflows. If this use case grows, adding a scratchpad reset option to persistent mode would be a natural enhancement.
